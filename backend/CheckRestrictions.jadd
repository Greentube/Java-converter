/**
 * Check the various restrictions that are imposed on the java code when converting.
 * All of those restrictions are checked a compile time to guarantee correct behavior
 * if the conversion succeeds.
 *
 * Basically the language features of java 1.7 are provided with the following restrictions:
 * - Threads   
 *      No threading is supported at all. No synchronization keywords either.      
 * - Exceptions
 *      No explicit exception handling. No throw and no try/catch. 
 *      Misbehavior of the program at runtime (NullPointerException,ArrayIndexOutOfBoundsException,
 *      CastException,etc.)
 *      will lead to undefined results (the C#-target will probably behave quite similar to java,
 *      but javascript will often silently ignore the problem and run into trouble later on).
 * - no 'long', 'short', 'float'
 *      These datatypes are either impossible to implement (javascript only supports a generic 
 *      Number type that can not hold a 64 bit quantity) or quite useless anyway (short, float).
 * - Auto-boxing, Auto-unboxing not supported
 *      This feature would be a horror to get right in all conversion targets. Since its use
 *      is already quite disfavored in the first place, the converter does not allow it at all.
 * - no 'instanceof' with array types.  
 *      In the javascript target, all arrays have the same runtime type. In theory it would be 
 *      possible to detect at runtime if an object is _some_ type of array, but this can
 *      not be directly written in java syntax.  
 * - Method overloading only based on number of parameters
 *      Instead of implementing the java way of using the full type signatures
 *      of all parameters, the javascript target uses a simpler system that 
 *      takes only the number of parameters into account. As a consequence, it is not possible
 *      to have multiple identically named methods with the same number of parameters 
 *      and the same static/non-static property in the same class.         
 * - No shadowing of fields and methods 
 *      No two instance fields in objects that are somehow inherited from each other can have the 
 *      same name - even if one or both are private. 
 *      Same holds for methods - but there the "name" is considered to be the 
 *      identifier in conjunction with the number-of-parameters.
 *      Static fields or methods do not have this restriction.
 *      Also local variables may shadow fields.
 * - Compound assignments can only use limited types of destination 
 *      When using any of the operators +=,-=,*=,... it is only possible to use 
 *      a local variable or a static or instance field of the current class as the destination. 
 *      This is to avoid potential double-evaluation behavior in various conversion targets. 
 * - Access to static members is not allowed by using an instance
 *      It is kind of legal in java to call a static method with something like: 
 *      exp.valueOf(4711)    // where exp is of type Integer 
 *      The possible side-effects of the first expression makes it impossible to just always
 *      eliminate it for conversion. Therefore this strange construction is not supported.
 *      (but you can use 'super' to access static members of superclasses) 
 * - Anonymous classes can not access local variables
 *      One of the more obscure features of java is the ability to access the local variables
 *      of the method defining the anonymous class - given that they are defined 'final'.
 *      Because the implementation in the conversion targets would be extremely complex, 
 *      it is not supported. If needed, use some other means to pass data into an anonymous class.        
 * - Different default implementation of hashCode()
 *      Objects not overriding hashCode will provide a default implementation may deliver
 *      an extremely weak hash (only depending on the object's class). Do not 
 *      use these as keys in any Hashtable/HashMap/HashSet. 
 *      The String objects will create a good hash, but a different one as is specified 
 *      in java. Do not rely on certain hash values for specific strings.
 * - Different default implementation of toString()
 *      Objects not overriding toString will provide a default implementation
 *      that is conversion target specific. Do only use to create a human readable debug output and
 *      do not rely on any specific format.   
 * - Limited subset of java core classes
 *      The converter core itself provides a very limited subset of the java core classes and
 *      also a limited number of methods in each. 
 *      Mainly the most crucial parts of java.lang and java.util are provided and a
 *      minimal version of java.io.PrintStream to make 'System.out' and 'System.err' available 
 *      for simple output. 
 */


aspect CheckRestrictions {
  	  	
  	public void ASTNode.checkRestrictions(ArrayList<String> errorlist) {  	
  		for (int i=0; i<getNumChild(); i++) {
  			getChild(i).checkRestrictions(errorlist);
  		}
  	}
  	
  	public void ASTNode.reportRestriction(ArrayList<String> errorlist, String message) {
  		int s = getStart();
  		errorlist.add(getLine(s)+","+getColumn(s)+": "+message);
  	}
  	
  	
  	// -- Threads 
	public void SynchronizedStmt.checkRestrictions(ArrayList<String> errorlist) {
		reportRestriction(errorlist, "Threading is not supported");
		super.checkRestrictions(errorlist);
	}

	// -- Exceptions
	public void ThrowStmt.checkRestrictions(ArrayList<String> errorlist) {
		reportRestriction(errorlist, "Exceptions are not supported");
		super.checkRestrictions(errorlist);
	}

	public void TryStmt.checkRestrictions(ArrayList<String> errorlist) {
		reportRestriction(errorlist, "Exceptions are not supported");
		super.checkRestrictions(errorlist);
	}

	public void ConstructorDecl.checkRestrictions(ArrayList<String> errorlist) {
		if (hasException()) {
			reportRestriction(errorlist, "Exceptions are not supported");
		}
		super.checkRestrictions(errorlist);
	}
	
	
	// -- Allowed primitive types 
	public void TypeAccess.checkRestrictions(ArrayList<String> errorlist) {
		TypeDecl t = type();
		if (t.isLong())  reportRestriction(errorlist, "Type 'long' not supported");
		if (t.isFloat()) reportRestriction(errorlist, "Type 'float' not supported");
		if (t.isShort()) reportRestriction(errorlist, "Type 'short' not supported");		
		super.checkRestrictions(errorlist);
	}

  	public void FloatType.checkRestrictions(ArrayList<String> errorlist) {
  		reportRestriction(errorlist, "Type 'float' not supported");  		
  	}  	
  	public void LongType.checkRestrictions(ArrayList<String> errorlist) {
  		reportRestriction(errorlist, "Type 'long' not supported");
  	}  	
  	public void ShortType.checkRestrictions(ArrayList<String> errorlist) {
  		reportRestriction(errorlist, "Type 'short' not supported");
  	}

  	public void FloatingPointLiteral.checkRestrictions(ArrayList<String> errorlist) {
  		reportRestriction(errorlist, "Type 'float' not supported");  		
  	}
  	public void LongLiteral.checkRestrictions(ArrayList<String> errorlist) {
  		reportRestriction(errorlist, "Type 'long' not supported");
  	}

	// no instanceof with arrays
  	public void InstanceOfExpr.checkRestrictions(ArrayList<String> errorlist) {
  	  	if (getTypeAccess().type().isArrayDecl()) {
  	  		reportRestriction(errorlist, "Can not create type check for array types");
  	  	}
		super.checkRestrictions(errorlist);
	}
		   	  	
		   	  			   	    	  
	// method overloading rules
	public void MethodDecl.checkRestrictions(ArrayList<String> errorlist) {
		// do not check for interfaces 
		if (hostType() instanceof ClassDecl) { 
		
			// check forbidden threading
			if (isSynchronized()) {		
				reportRestriction(errorlist, "Threading is not supported");
			}
			// check forbidden exceptions
			if (hasException()) {
				reportRestriction(errorlist, "Exceptions are not supported");
			}
			
			// check method name collisions	in same class		
			ClassDecl cd = (ClassDecl)hostType();
			for (BodyDecl bd:cd.getBodyDeclList()) {
				// no two methods with same name and number of arguments in same class
				// if both are either static or non-static
				if ((bd instanceof MethodDecl) && bd!=this) {
					MethodDecl md = (MethodDecl) bd;
					if (md.getID().equals(getID())
					&&  md.getNumParameter()==getNumParameter()
					&&  md.isStatic() == isStatic()) {
						reportRestriction(errorlist, 
						 (isStatic() ? "Static" : "Non-static") + " method "
					+ "'"+getID()+"' with "+getNumParameter()
					+ " parameter(s) conflicts with other method defined in same class");
					}				
				}
			}
			
// TODO check for collisions in the inheritance chain			
		}
		
		super.checkRestrictions(errorlist);		
	}
	
	// shadowing field identifiers
	public void FieldDeclarator.checkRestrictions(ArrayList<String> errorlist) {
		if (!isStatic()) {
			ClassDecl cd = (ClassDecl) ((ClassDecl)hostType()).superclass();
			while(!cd.isObject()) {
				for (BodyDecl bd:cd.getBodyDeclList()) {
					if (bd.isField()) {
						for (FieldDeclarator fd:bd.fieldDeclarations()) {
							if (!fd.isStatic() && fd.getID().equals(getID())) {
  								reportRestriction(errorlist, "Field '"+getID()+"' must not shadow parent field");								
							}
						}
					}
				}
				cd = (ClassDecl) cd.superclass();
			}
		}
		super.checkRestrictions(errorlist);		
	}

	// Compound assignments can only use limited types of destination
	public void AssignExpr.checkRestrictions(ArrayList<String> errorlist)
	{
		if (!(this instanceof AssignSimpleExpr)) {
			boolean isok = false;
			Expr d = getDest();
			if (d instanceof VarAccess) {
				Variable v = ((VarAccess)d).varDecl();
				// can use class variables or locals
				if (v.isClassVariable() || v.isLocalVariable() || v.isParameter()) {
					isok = true;
				} else if (v.isInstanceVariable()) {
					// can use non-static fields that have no accessor
					if (!isRightChildOfDot()) {
						isok = true;
					// can use non-static fields of 'this' 
					} else if (d.prevExpr() instanceof ThisAccess) {
						isok = true;
					}
				}  				
			}
			if (!isok) {
				reportRestriction(errorlist, "Can only use compound assignment directly with fields or local variables");			
			}
		}
		super.checkRestrictions(errorlist);					
	}
	 

	// Access to static members is not allowed by using an instance
	public void AbstractDot.checkRestrictions(ArrayList<String> errorlist) {
		Expr l = getLeft();
		Access r = getRight();
		if ((r instanceof MethodAccess) && ((MethodAccess) r).decl().isStatic()) {
			if (! (l instanceof TypeAccess) && ! (l instanceof SuperAccess)) {
				 reportRestriction(errorlist, "Can not access static method '"
				 + ((MethodAccess) r).decl().getID()
				 +"' with instance expression");
			}
		}
		if ((r instanceof VarAccess) && ((VarAccess) r).varDecl().isStatic()) {
			if (! (l instanceof TypeAccess) && ! (l instanceof SuperAccess)) {
				 reportRestriction(errorlist, "Can not access static field '"
				  + ((VarAccess) r).varDecl().name() 
				  + "' with instance expression");
			}
		}
		super.checkRestrictions(errorlist);
	}  		
	
		   	  	
	// anonymous classes may not access surrounding local variables
	public void VarAccess.checkRestrictions(ArrayList<String> errorlist) {
		Variable v = varDecl();
		if (v.isLocalVariable() || v.isParameter()) {	
			if (v.hostType() != hostType()) {
				reportRestriction(errorlist, "Can not access local variables of outer class method");
			}
		}		
		super.checkRestrictions(errorlist);
	}
		  	
}
