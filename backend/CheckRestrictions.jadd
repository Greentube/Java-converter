/**
 * Check the various restrictions that are imposed on the java code when converting.
 * All of those restrictions are checked a compile time to guarantee correct behavior
 * if the conversion succeeds.
 *
 * Basically the language features of java 1.7 are provided with the following exceptions.
 * - Threads   
 *      No threading is supported at all. No synchronization keywords either.      
 * - Exceptions
 *      No explicit exception handling. No throw and no try/catch. 
 *      Misbehavior of the program at runtime (NullPointerException,ArrayOutOfBounds,etc.) 
 *      will lead to undefined results (the C#-target will probably behave quite similar to java,
 *      but javascript will often silently ignore the problem and run into trouble later on).
 * - no 'long', 'short', 'float'
 *      These datatypes are either impossible to implement (javascript only supports a generic 
 *      Number type that can not hold a 64 bit quantity) or quite useless anyway (short, float).
 * - Auto-boxing, Auto-unboxing not supported
 *      This feature would be a horror to get right in all conversion targets. Since its use
 *      is quite disfavored in the first place, the converter does no allow it at all.  
 * - Method overloading only based on number of parameters
 *      Instead of implementing the java way of using the full type signatures
 *      of all parameters, the javascript target uses a simpler system that 
 *      takes only the number of parameters into account. As a consequence, it is not possible
 *      to have multiple identically named methods with the same number of parameters.   
 * - Fields and methods in one inheritance chain must not conflict. 
 *      No two instance fields in objects that are somehow inherited from each other can have the 
 *      same name - even if one or both are private. 
 *      Same holds for methods - but there the "name" is considered to be the 
 *      identifier in conjunction with the number-of-parameters.
        Static fields or methods do not have this restriction.
 * - no reflection
 *      The internal structure of the targets runtime is quite different to the java runtime and
 *      the whole releflection framework (beginning with the Class object) is not implemented.   
 * - no 'instanceof' with array types.  
 *      In the javascript target, all arrays have the same runtime type. In theory it would be 
 *      possible to detect at runtime if an object is _some_ type of array, but this can
 *      not be directly written in java syntax. 
 * - Anonymous classes can not access local variables
 *      One of the more obscure features of java is the ability to access the local variables
 *      of the method defining the anonymous class - given that they are defined 'final'.
 *      Because the implementation in the conversion targets would be extremely complex, 
 *      it is not supported. If needed, use some other means to pass data into an anonymous class.       
 */


aspect CheckRestrictions {
  	  	
  	public void ASTNode.checkRestrictions(ArrayList<String> errorlist) {  	
  		for (int i=0; i<getNumChild(); i++) {
  			getChild(i).checkRestrictions(errorlist);
  		}
  	}
  	
  	// -- Threads  (and part of Exceptions)
	public void MethodDecl.checkRestrictions(ArrayList<String> errorlist) {
		if (isSynchronized()) {		
			errorlist.add("Threading is not supported");
		}
		if (hasException()) {
			errorlist.add("Exceptions are not supported");
		}
		super.checkRestrictions(errorlist);
	}

	public void SynchronizedStmt.checkRestrictions(ArrayList<String> errorlist) {
		errorlist.add("Threading is not supported");
		super.checkRestrictions(errorlist);
	}

	// -- Exceptions
	public void ThrowStmt.checkRestrictions(ArrayList<String> errorlist) {
		errorlist.add("Exceptions are not supported");
		super.checkRestrictions(errorlist);
	}

	public void TryStmt.checkRestrictions(ArrayList<String> errorlist) {
		errorlist.add("Exceptions are not supported");
		super.checkRestrictions(errorlist);
	}

	public void ConstructorDecl.checkRestrictions(ArrayList<String> errorlist) {
		if (hasException()) {
			errorlist.add("Exceptions are not supported");
		}
		super.checkRestrictions(errorlist);
	}
	
	
	// -- Allowed primitive types 
	public void TypeAccess.checkRestrictions(ArrayList<String> errorlist) {
		TypeDecl t = type();
		if (t.isLong())  errorlist.add("Type 'long' not supported");
		if (t.isFloat()) errorlist.add("Type 'float' not supported");
		if (t.isShort()) errorlist.add("Type 'short' not supported");		
		super.checkRestrictions(errorlist);
	}

  	public void FloatType.checkRestrictions(ArrayList<String> errorlist) {
  		errorlist.add("Type 'float' not supported");  		
  	}  	
  	public void LongType.checkRestrictions(ArrayList<String> errorlist) {
  		errorlist.add("Type 'long' not supported");
  	}  	
  	public void ShortType.checkRestrictions(ArrayList<String> errorlist) {
  		errorlist.add("Type 'short' not supported");
  	}

  	public void FloatingPointLiteral.checkRestrictions(ArrayList<String> errorlist) {
  		errorlist.add("Type 'float' not supported");  		
  	}
  	public void LongLiteral.checkRestrictions(ArrayList<String> errorlist) {
  		errorlist.add("Type 'long' not supported");
  	}
  	  	
  	
  	public void AssignExpr.checkRestrictions(ArrayList<String> errorlist) {
  		if (! (this instanceof AssignSimpleExpr)) {
  			if (getDest().expressionHasPotentialSideEffects()) {
  				errorlist.add("Can not use compound assignment '"+printOp()+"' with side effects in target operand");
  			}  		
  		}
		super.checkRestrictions(errorlist);
	}		
		
	public boolean ASTNode.expressionHasPotentialSideEffects() {
  		for (int i=0; i<getNumChild(); i++) {
  			if (getChild(i).expressionHasPotentialSideEffects()) return true;
  		}
  		return false;
	}  	
  	public boolean ConstructorAccess.expressionHasPotentialSideEffects() {
  		return true;
  	}
  	public boolean MethodAccess.expressionHasPotentialSideEffects() {
  		return true;
  	}  	  	
  	public boolean AssignExpr.expressionHasPotentialSideEffects() {
  		return true;
  	}
  	public boolean PostfixExpr.expressionHasPotentialSideEffects() {
  		return true;
  	}
  	public boolean PreDecExpr.expressionHasPotentialSideEffects() {
  		return true;
  	}
  	public boolean PreIncExpr.expressionHasPotentialSideEffects() {
  		return true;
  	}
  	
}
