import com.greentube.javaconverter.CodePrinter;
aspect GenerateJS {
 
 	public void Expr.generateUsingResultJS(CodePrinter out) {	
		if (isConstant() && !type().isEnumDecl()) {
			constant().generateJS(out);  					
 		} else { 	
            generateJS(out);
 		}
	}

	 
 	// --- Access --- 
 	
  	public void Dot.generateJS(CodePrinter out) {
  	    // search down the tree to find the end of the AbstactDot sequence  	    
  		Access a = getRight();
  		while (a instanceof Dot) {
  		    a = ((Dot)a).getRight();
  		}
  		if (a instanceof ClassInstanceExpr) {
  		    // do not generate enclosing instance expression here - must be done by constructor
  		    a.generateJS(out);  		    
  		} else if ((a instanceof MethodAccess) && ((MethodAccess)a).decl().isStatic()) {
  		    // do not generate instance expression when calling static method
            a.generateJS(out);              
        } else if ((a instanceof VarAccess) && ((VarAccess)a).decl().isStatic()) {
            // do not generate instance expression when accessing static variable
            a.generateJS(out);              
  		} else {
  		    // generate everything
            getLeft().generateJS(out);
            getRight().generateJS(out);
  		}
 	}
//  	public void Wildcard.generateJS(CodePrinter out) {
// 	}
//  	public void WildcardExtends.generateJS(CodePrinter out) {
// 	}
//  	public void WildcardSuper.generateJS(CodePrinter out) {
// 	}
  	public void ArrayAccess.generateJS(CodePrinter out) {
  		out.print("[");
  		getExpr().generateUsingResultJS(out);
  		out.print("]");
 	}
//  	public void ClassAccess.generateJS(CodePrinter out) {
// 	}
    public void ClassInstanceExpr.generateJS(CodePrinter out) 
    {   if (transformed()!=this)
        {   transformed().generateJS(out);
            return;
        }
        // special construction of string objects
        if (type().isString()) {
            out.print(getNumArg()<=1 ? "_array2str" : "_subarray2str");
            out.print("(");
            for (int i=0; i<getNumArg(); i++) {
                if (i>0) out.print(",");
                getArg(i).generateUsingResultJS(out);
            }
            out.print(")");
            return;
        }

        boolean foundpar=false;
        out.print("(new ");
        out.printAndMemorizeReference(type().packageName(), type().uniqueName());
        out.print(".$(");
        if (isRightChildOfDot()) 
        {   prevExpr().generateJS(out);
            foundpar=true;
        }
        else if (type().needsEnclosing()) 
        {   out.print("this");
            foundpar=true;
        }
        for (Variable v:type().enclosingVariables()) {
            if (foundpar) out.print(",");
            out.printCSIdentifier(v.name());
            foundpar=true;
        }        
        out.print("))");

        ConstructorDecl m = decl();
        out.print("._"+m.getNumParameter()+"(");        
        for (int i=0; i<getNumArg(); i++) {
            if (i>0) out.print(",");
            getArg(i).generateUsingResultJS(out);
        }
        out.print(")");

        // check if this is inside a static initializer - must force early loading of created class
        if (enclosingBodyDecl().isField()) {
            out.memorizeComplete(type().packageName(),type().uniqueName());
        }
    }
    public void ConstructorAccess.generateJS(CodePrinter out) 
    {   if (transformed()!=this)
        {   transformed().generateJS(out);
            return;
        }

        TypeDecl ht = decl().hostType();
        out.printAndMemorizeReference(ht.packageName(), ht.uniqueName());

        ConstructorDecl m = decl();
        out.print(".$.prototype._" + m.getNumParameter() + ".call(this");
        for (int i=0; i<getNumArg(); i++) 
        {   out.print(",");
            getArg(i).generateUsingResultJS(out);
        }
        out.print(")");
    }

//  	public void DiamondAccess.generateJS(CodePrinter out) {
// 	}
    public void MethodAccess.generateJS(CodePrinter out) 
    {   if (transformed()!=this)
        {   transformed().generateJS(out);
            return;
        }

        MethodDecl m = decl();
        if (m.isStatic()) 
        {   TypeDecl t = m.hostType();
            String tname = t.uniqueName();
            String n = m.name();
            // special handling of the Math.abs method
            if (t.packageName().equals("java.lang") && t.uniqueName().equals("Math")) 
            {   if (n.equals("abs") && m.type().isInt()) 
                {   n = "absInt";
                }
            }        
            out.printAndMemorizeReference(t.packageName(),tname);
            out.print(".");
            out.printJSIdentifier(n,"_"+m.getNumParameter());
            out.print("(");

            // check if this is inside a static initializer - 
            //must force early loading of accessed class
            BodyDecl bd = enclosingBodyDecl();
            if (bd.isField() || (bd instanceof StaticInitializer)) 
            {   out.memorizeComplete(t.packageName(),t.uniqueName());
            }
        } 
        else if (!isRightChildOfDot()) 
        {   out.print("this.");
            TypeDecl t = hostType();
            if (t!=m.hostType() && t.isInnerTypeOf(m.hostType())) 
            {   while (t!=m.hostType()) 
                {   out.print("_o.");
                    t = t.enclosingType();
                }
            }
            out.printJSIdentifier(m.name(),"_"+m.getNumParameter());
            out.print("(");
        }
        else if (prevExpr().isSuperAccess()) 
        {   out.printAndMemorizeReference(m.hostType().packageName(),m.hostType().uniqueName());
            out.print(".$.prototype.");  		
            out.printJSIdentifier(m.name(),"_"+m.getNumParameter());
            out.print(".call(this");
            if (m.getNumParameter()>0) out.print(",");
        }
        else
        {   out.print(".");
            out.printJSIdentifier(m.name(),"_"+m.getNumParameter());
            out.print("(");
        }

        // generate parameters 
        for (int i=0; i<getNumArg(); i++) {
            if (i>0) out.print(",");
            // do necessary data conversion for some built-in methods 
            // to clarify the use of a char instead of a int 
            TypeDecl ht = m.hostType();
            String tn = ht.packageName() + "." + ht.uniqueName();
            if 
            (   i==0 && getNumArg()==1 && 
                (   (m.name().equals("append") && tn.equals("java.lang.StringBuffer"))
                    || (m.name().equals("append") && tn.equals("java.lang.StringBuilder"))
                    || (m.name().equals("print") && tn.equals("java.io.PrintStream"))
                    || (m.name().equals("println") && tn.equals("java.io.PrintStream"))
                ) 
            ) 
            {   TypeDecl at = getArg(0).type(); 
                if (at.isChar()) 
                {   out.print("_c2s(");  	
                    getArg(i).generateUsingResultJS(out);
                    out.print(")");
                }
                else if (at.isPrimitiveType()) 
                {   out.print("_p2s(");     
                    getArg(i).generateUsingResultJS(out);
                    out.print(")");
                }
                else 
                {   getArg(i).generateUsingResultJS(out);
                }	
            } 
            // do conversion of regex parameter for the String.split method
            else if (i==0 && m.name().equals("split") && tn.equals("java.lang.String"))
            {   String ss = getArg(0).regexToSearchString();
                Constant.generateStringJS(out,ss);
            }
            else 
            {  getArg(i).generateUsingResultJS(out);
            }
        }
        out.print(")");
    }

//  	public void PackageAccess.generateJS(CodePrinter out) {
// 	}
//  	public void ParseName.generateJS(CodePrinter out) {
// 	}
  	public void SuperAccess.generateJS(CodePrinter out) {
  		// do not generate anything - must be implemented by the method or variable access
 	}
  	public void ThisAccess.generateJS(CodePrinter out) {
        // do not generate anything for static access - must be implemented by the method or variable access
        if (isLeftChildOfDot()) {
            Access n = nextAccess();
            if ((n instanceof MethodAccess) && ((MethodAccess)n).decl().isStatic()) return;
            if ((n instanceof VarAccess) && ((VarAccess)n).decl().isStatic()) return;
        }
        out.print("this");
        // check if accessing the instance of an outer class
        TypeDecl t = hostType();
        if (t!=type() && t.isInnerTypeOf(type())) {
            while (t!=type()) {
                out.print("._o");
                t = t.enclosingType();
            }
        }       
    }
  	public void TypeAccess.generateJS(CodePrinter out) {
 	}
  	public void ArrayTypeAccess.generateJS(CodePrinter out) {
  		getAccess().generateJS(out);
	}
  	public void ArrayTypeWithSizeAccess.generateJS(CodePrinter out) {
  		getAccess().generateJS(out);
  		getExpr().generateJS(out);
  		out.print(",");
	}   	

  	public void VarAccess.generateJS(CodePrinter out) {
  		Variable v = varDecl();
  		if (v.isClassVariable()) {
  			TypeDecl t = v.hostType();
  			out.printAndMemorizeReference(t.packageName(),t.uniqueName());  		
  			out.print(".");
  			out.printJSIdentifier(getID(),"");  
  			// check if this is inside a static initializer - must force early loading of accessed class
	  		BodyDecl bd = enclosingBodyDecl();
  			if (bd.isField() || (bd instanceof StaticInitializer)) {
  				out.memorizeComplete(t.packageName(),t.uniqueName());
  			}  		  						  			
  		} else if (v.isInstanceVariable()) {
			if (!hasPrevExpr()) {
				out.print("this.");
				TypeDecl t = hostType();
				if (t!=v.hostType() && t.isInnerTypeOf(v.hostType())) {
					while (t!=v.hostType()) {
						out.print("_o.");
						t = t.enclosingType();
					}
				}  		
  			} else {  		
                out.print(".");
            } 
			out.printJSIdentifier(getID(),"");
        } else if (v.isLocalVariable() || v.isParameter()) 
        {   if (v.hostType() == hostType()) 
            {   out.printJSIdentifier(getID(), "");
            }
            else 
            {   // this must be an access to local variable of calling method
                out.print("this.");
                out.printJSIdentifier(getID(), "_o");
            }
		} else if (getID().equals("length")) {
			out.print(".length");
  		} else {
			throw new RuntimeException("Unknown type of variable access");
  		}  		
 	}
  	
  	// --- ArrayInit ---
  	
    public void ArrayInit.generateJS(CodePrinter out) 
    {   out.print("_arr(");
        out.print("\"");
        out.print(type().typeDescriptor());
        out.print("\",");
        out.print("[");
        for (int i=0; i<getNumInit(); i++) {
            if (i>0) out.print(",");
            getInit(i).generateUsingResultJS(out);
        }
        out.print("])");
    }

  	// --- AssignExpr ---

	public void AssignExpr.generateWithOptionalCastJS(CodePrinter out, String operator) {
  		Expr d = getDest();
  		Expr s = getSource();
  		if (d.type().isDouble()) {
	  		d.generateJS(out);
	  		out.print(" ");
	  		out.print(operator);
  			out.print("= ");
  			s.generateUsingResultJS(out);
  		} else if (s.type().isDouble()) {
	  		d.generateJS(out);
  			out.print(" = ");
  			if (d.type().isByte()) {
  				out.print("_castTObyte(");
  			} else if (d.type().isChar()) {
  				out.print("_castTOchar(");
  			} else if (d.type().isInt()) {
  				out.print("_castTOint(");
  			} else {
  				throw new RuntimeException("Can not implicitly cast to destination type");
  			}
	  		d.generateJS(out);
	  		out.print(" ");
	  		out.print(operator);
	  		out.print(" ");
  			s.generateUsingResultJS(out);
			out.print(")");
  		} else {
  			d.generateJS(out);
  			out.print(" = ((");
  			d.generateJS(out);
  			out.print(" ");
  			out.print(operator);
  			out.print(" ");
  			getSource().generateUsingResultJS(out);
  			out.print(")|0)");  		
  		}
	}

  	public void AssignMinusExpr.generateJS(CodePrinter out) {
  		generateWithOptionalCastJS(out,"-");
  	}
  	public void AssignPlusExpr.generateJS(CodePrinter out) {
  		// do some case discrimination if this is a string concatenation
  		Expr d = getDest();
  		Expr s = getSource();
  		if (type().isString()) {
  			d.generateJS(out);
  			out.print(" += \"\"+");
  			if (s.type().isChar()) {
  				out.print("_c2s(");
  				s.generateJS(out);
  				out.print(")");
  			} else {
  				s.generateJS(out);
  			}
  		} else {
	  		generateWithOptionalCastJS(out,"+");
  		}
  	}
  	public void AssignMulExpr.generateJS(CodePrinter out) {
        // do some case discrimination if this is an int multiplication with large operands        
        Expr d = getDest();
        Expr s = getSource();
        if (d.type().isInt() && s.type().isInt()) {
            if (!d.hasLessThan20Bits() && !s.hasLessThan20Bits()) {
                d.generateJS(out);
                out.print(" = _imul(");
                d.generateJS(out);
                out.print(" , ");
                s.generateJS(out);
                out.print(")");
                return;
            }
        }
  		generateWithOptionalCastJS(out,"*");
  	}  	
  	public void AssignDivExpr.generateJS(CodePrinter out) {
  		generateWithOptionalCastJS(out,"/");
  	}
  	
  	public void AssignAndExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" &= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignOrExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" |= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignXorExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" ^= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignModExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" %= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignLShiftExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" <<= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignRShiftExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" >>= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignURShiftExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" >>>= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignSimpleExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" = ");
  		getSource().generateUsingResultJS(out);
  	}
  	  	
  	// --- Binary ---

  	public void AddExpr.generateJS(CodePrinter out) {
  		// do some case discrimination if this is a string concatenation
  		Expr l = getLeftOperand();
  		Expr r = getRightOperand();
  		if (type().isString()) {
			if ((l.type().isString() && l.isConstant()) || (l instanceof AddExpr)) {
				l.generateUsingResultJS(out);
  			} else if (l.type().isChar()) {
  				out.print("_c2s(");
  				l.generateUsingResultJS(out);
  				out.print(")");
			} else if (l.type().isReferenceType()) {
  				out.print("_str(");
  				l.generateUsingResultJS(out);
  				out.print(")");  		
  			} else {
  				l.generateUsingResultJS(out);
  			}
  			out.print("+\"\"+");
			if ((r.type().isString() && r.isConstant()) || (r instanceof AddExpr)) {
				r.generateUsingResultJS(out);
  			} else if (r.type().isChar()) {
  				out.print("_c2s(");
  				r.generateUsingResultJS(out);
  				out.print(")");
  			} else if (r.type().isReferenceType()) {
  				out.print("_str(");
  				r.generateUsingResultJS(out);
  				out.print(")");  		
  			} else {
  				r.generateUsingResultJS(out);  			 
  			}
  		} else if (type().isDouble()) {
	  		l.generateUsingResultJS(out);
  			out.print(" + ");
  			r.generateUsingResultJS(out);
  		} else {
  			out.print("((");
	  		l.generateUsingResultJS(out);
  			out.print(" + ");
  			r.generateUsingResultJS(out);
  			out.print(")|0)");
  		}
  	}
  	public void SubExpr.generateJS(CodePrinter out) {
  		Expr l = getLeftOperand();
  		Expr r = getRightOperand();  	
  		if (type().isDouble()) {
	  		l.generateUsingResultJS(out);
  			out.print(" - ");
  			r.generateUsingResultJS(out);
  		} else {
  			out.print("((");
	  		l.generateUsingResultJS(out);
  			out.print(" - ");
  			r.generateUsingResultJS(out);
  			out.print(")|0)");
  		}
  	}
  	public void DivExpr.generateJS(CodePrinter out) {
	  		Expr l = getLeftOperand();
  			Expr r = getRightOperand();  	
		if (type().isDouble()) {
	  		l.generateUsingResultJS(out);
  			out.print(" / ");
  			r.generateUsingResultJS(out);
  		} else {  	
  			out.print("((");
	  		l.generateUsingResultJS(out);
  			out.print(" / ");
  			r.generateUsingResultJS(out);
  			out.print(")|0)");
  		}
  	}
  	public void MulExpr.generateJS(CodePrinter out) {
  		Expr l = getLeftOperand();
  		Expr r = getRightOperand();  	
  		if (type().isDouble()) {
	  		l.generateUsingResultJS(out);
  			out.print(" * ");
  			r.generateUsingResultJS(out);
  		} else if (l.hasLessThan20Bits() || r.hasLessThan20Bits()) {
            out.print("((");
            l.generateUsingResultJS(out);
            out.print(" * ");
            r.generateUsingResultJS(out);
            out.print(")|0)");
        } else {
            out.print("_imul(");
            l.generateUsingResultJS(out);
            out.print(" , ");
            r.generateUsingResultJS(out);
            out.print(")");  		
  		}
  	}
  	public void ModExpr.generateJS(CodePrinter out) {
 		getLeftOperand().generateUsingResultJS(out);
		out.print(" % ");
		getRightOperand().generateUsingResultJS(out);
  	}  	
  	public void AndBitwiseExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" & ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void OrBitwiseExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" | ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void XorBitwiseExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" ^ ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void AndLogicalExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" && ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void OrLogicalExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" || ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void EQExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" === ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void NEExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" !== ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void GEExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" >= ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void GTExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" > ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void LEExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" <= ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void LTExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" < ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void LShiftExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" << ");
  		getRightOperand().generateUsingResultJS(out);

  	}
  	public void RShiftExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" >> ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void URShiftExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" >>> ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	
  	
  	// --- CastExpr ---
  	
  	public void CastExpr.generateJS(CodePrinter out) {
		TypeDecl t = type();
		if (t.isPrimitiveType()) {
			if (t.isByte()) { 
				out.print("_castTObyte(");
				getExpr().generateUsingResultJS(out);
				out.print(")");
			} else if (t.isChar()) {
				out.print("_castTOchar(");
				getExpr().generateUsingResultJS(out);
				out.print(")");
			} else if (t.isInt()) {
				out.print("_castTOint(");
				getExpr().generateUsingResultJS(out);
				out.print(")");
			} else if (t.isDouble()) {
				getExpr().generateUsingResultJS(out);
			} else {
				throw new RuntimeException("Type not supported:"+t.fullName());
			}
		} else {
  			getExpr().generateUsingResultJS(out);
  		}
  	}
  	
  	// --- ConditionalExpr ---
  	
  	public void ConditionalExpr.generateJS(CodePrinter out) {
  		getCondition().generateUsingResultJS(out);
  		out.print("?");
  		getTrueExpr().generateUsingResultJS(out);
  		out.print(":");
  		getFalseExpr().generateUsingResultJS(out);
  	}
  	
  	// --- InstanceOfExpr ---

    public void InstanceOfExpr.generateJS(CodePrinter out) {
        TypeDecl t = getTypeAccess().type();
        if (t.isArrayDecl()) 
        {   out.print("_isarray(");
            getExpr().generateUsingResultJS(out);
            out.print(",\"");
            out.print(t.typeDescriptor());
            out.print("\")");
        }
        else if (!t.isReferenceType()) 
        {   out.print("false");
            throw new RuntimeException("Can not create type check for primitive types");
        }
        else if (t.isInterfaceDecl()) 
        {   out.print("_implements(");
            getExpr().generateUsingResultJS(out);
            out.print(",");
            out.printAndMemorizeReference(t.packageName(),t.uniqueName());
            out.print(")");
        }
        else if (t.isString())
        {   out.print("_isstr(");
            getExpr().generateUsingResultJS(out);
            out.print(")");
        }        
        else if (t.isObject())        
        {   out.print("((");
            getExpr().generateUsingResultJS(out);
            out.print(")!=null)");
        } 
        else {          
            out.print("(");  
            getExpr().generateUsingResultJS(out);
            out.print(" instanceof ");
            out.printAndMemorizeReference(t.packageName(),t.uniqueName());
            out.print(".$)");
        }
    }

  	// --- PrimaryExpr ---
  	
  	public void ArrayCreationExpr.generateJS(CodePrinter out) {
  		if (hasArrayInit()) {
  			getArrayInit().generateJS(out);
  		} else {
            Access ta = getTypeAccess();
            out.print("_dim(");
            out.print("\"");
            out.print(ta.type().typeDescriptor());
            out.print("\"");
	  		out.print(",[");
			ta.generateJS(out);
			out.print("],");
			if ((ta instanceof ArrayTypeWithSizeAccess) 
			 && ta.type().elementType().isPrimitiveType()) { 
				out.print(ta.type().elementType().isBoolean()?"false":"0");
			} else {
				out.print("null");
			}								
			out.print(")");  		
  		}
  	}
  	public void Literal.generateJS(CodePrinter out) {
  		constant().generateJS(out);
  	}
//  	public void IllegalLiteral.generateCS(CodePrinter out) {
//  	}
  	public void NullLiteral.generateJS(CodePrinter out) {
  		out.print("null");
  	}
  	
  	public void ParExpr.generateJS(CodePrinter out) {
  		out.print("(");
  		getExpr().generateJS(out);
  		out.print(")");
  	}
  	
  	// --- Unary ---
  	public void BitNotExpr.generateJS(CodePrinter out) {
  		out.print(" ~ ");
  		getOperand().generateUsingResultJS(out);  	
  	}
  	public void LogNotExpr.generateJS(CodePrinter out) {
  		out.print(" ! ");
  		getOperand().generateUsingResultJS(out);  	
  	}
    public void MinusExpr.generateJS(CodePrinter out) {
        if (type().isDouble()) 
        {   out.print("-");
            getOperand().generateUsingResultJS(out);
        } 
        else     
        {   out.print("(-(");
            getOperand().generateUsingResultJS(out);  	
            out.print(")|0)");
        }
    }
  	public void PlusExpr.generateJS(CodePrinter out) {
  		getOperand().generateUsingResultJS(out);  	
  	}
  	
  	
  	public void Unary.generatePostOperatorJS(CodePrinter out, boolean inc)
  	{
  		Expr e = getOperand();
  		if (e.type().isDouble()) {
  			e.generateJS(out);
  			out.print(inc?" ++ ":" -- ");
  			return;
  		}
  		
  		boolean needresult = !(getParent() instanceof ExprStmt);
  		if (needresult) {
  			out.print("(((");
  		}
  		
		e.generateUsingResultJS(out);
		out.print("=(");
		e.generateUsingResultJS(out);
		out.print(inc?" +1)":" -1)");
		if (e.type().isInt()) {
			out.print("|0");
		} else if (e.type().isChar()) {
			out.print("&0xffff");
		} else if (e.type().isByte()) {
			out.print("<<24>>24");
		}
  	
  		if (needresult) {
  			out.print(")");
  			// must revert the operation to get the original value out
			out.print(inc?" -1)":" +1)");
			if (e.type().isInt()) {
				out.print("|0");
			} else if (e.type().isChar()) {
				out.print("&0xffff");
			} else if (e.type().isByte()) {
				out.print("<<24>>24");
			}
			out.print(")");
  		}  	  	
  	}
  	public void Unary.generatePreOperatorJS(CodePrinter out, boolean inc)
  	{
  		Expr e = getOperand();
  		if (e.type().isDouble()) {
  			out.print(inc?" ++ ":" -- ");
  			e.generateJS(out);
  			return;
  		}
  		
  		boolean needresult = !(getParent() instanceof ExprStmt);
  		if (needresult) {
  			out.print("(");
  		}
		
		e.generateUsingResultJS(out);
		out.print("=(");
		e.generateUsingResultJS(out);
		out.print(inc?" +1)":" -1)");
		if (e.type().isInt()) {
			out.print("|0");
		} else if (e.type().isChar()) {
			out.print("&0xffff");
		} else if (e.type().isByte()) {
			out.print("<<24>>24");
		}
		
  		if (needresult) {
  			out.print(")");
  		}  	
  	}  	
  	public void PostDecExpr.generateJS(CodePrinter out) {
  		generatePostOperatorJS(out, false);
  	}
  	public void PostIncExpr.generateJS(CodePrinter out) {
  		generatePostOperatorJS(out, true);
  	}
  	public void PreDecExpr.generateJS(CodePrinter out) {
  		generatePreOperatorJS(out,false);
  	}
  	public void PreIncExpr.generateJS(CodePrinter out) {
  		generatePreOperatorJS(out,true);
  	}  	

  	public void LambdaExpr.generateJS(CodePrinter out) 
  	{    
  	     toClass().generateJS(out); 
  	}
  	public void TypeMethodReference.generateJS(CodePrinter out)
  	{    
  	     toClass().generateJS(out); 
  	}
    public void ExprMethodReference.generateJS(CodePrinter out)
    {    
         toClass().generateJS(out); 
    }
  	
}

