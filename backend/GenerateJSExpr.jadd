import com.greentube.javaconverter.CodePrinter;
aspect GenerateJS {
 
 	public void Expr.generateUsingResultJS(CodePrinter out) {	
		if (isConstant() && !type().isEnumDecl()) {
			constant().generateJS(out);  		
 		} else {
 			generateJS(out);
 		}
	}
	 
 	// --- Access --- 
 	
  	public void AbstractDot.generateJS(CodePrinter out) {
  		Access a = getRight();
  		if (! (a instanceof ClassInstanceExpr)) {
  			getLeft().generateJS(out);
  		}
  		a.generateJS(out);
 	}
//  	public void Wildcard.generateJS(CodePrinter out) {
// 	}
//  	public void WildcardExtends.generateJS(CodePrinter out) {
// 	}
//  	public void WildcardSuper.generateJS(CodePrinter out) {
// 	}
  	public void ArrayAccess.generateJS(CodePrinter out) {
  		out.print("[");
  		getExpr().generateUsingResultJS(out);
  		out.print("]");
 	}
//  	public void ClassAccess.generateJS(CodePrinter out) {
// 	}
    public void ClassInstanceExpr.generateJS(CodePrinter out) 
    {   if (transformed()!=this)
        {   transformed().generateJS(out);
            return;
        }

        boolean foundpar=false;
        out.print("(new ");
        out.printAndMemorizeReference(type().packageName(), type().uniqueName());
        out.print("(");
        if (isRightChildOfDot()) 
        {   prevExpr().generateJS(out);
            foundpar=true;
        }
        else if (type().needsEnclosing()) 
        {   out.print("this");
            foundpar=true;
        }
        for (Variable v:type().enclosingVariables()) {
            if (foundpar) out.print(",");
            out.printCSIdentifier(v.name());
            foundpar=true;
        }        
        out.print("))");

        ConstructorDecl m = decl();
        out.print("._"+m.getNumParameter()+"(");        
        for (int i=0; i<getNumArg(); i++) {
            if (i>0) out.print(",");
            getArg(i).generateUsingResultJS(out);
        }
        out.print(")");

        // check if this is inside a static initializer - must force early loading of created class
        if (enclosingBodyDecl().isField()) {
            out.memorizeComplete(type().packageName(),type().uniqueName());
        }
    }
    public void ConstructorAccess.generateJS(CodePrinter out) 
    {   if (transformed()!=this)
        {   transformed().generateJS(out);
            return;
        }

        TypeDecl ht = decl().hostType();
        out.printAndMemorizeReference(ht.packageName(), ht.uniqueName());

        ConstructorDecl m = decl();
        out.print(".prototype._" + m.getNumParameter() + ".call(this");
        for (int i=0; i<getNumArg(); i++) 
        {   out.print(",");
            getArg(i).generateUsingResultJS(out);
        }
        out.print(")");
    }

//  	public void DiamondAccess.generateJS(CodePrinter out) {
// 	}
    public void MethodAccess.generateJS(CodePrinter out) 
    {   if (transformed()!=this)
        {   transformed().generateJS(out);
            return;
        }

        MethodDecl m = decl();
        if (m.isStatic()) 
        {   TypeDecl t = m.hostType();
            out.printAndMemorizeReference(t.packageName(),t.uniqueName());
            out.print(".");
            out.printJSIdentifier(m.name(),"_"+m.getNumParameter());
            out.print("(");

            // check if this is inside a static initializer - 
            //must force early loading of accessed class
            BodyDecl bd = enclosingBodyDecl();
            if (bd.isField() || (bd instanceof StaticInitializer)) 
            {   out.memorizeComplete(t.packageName(),t.uniqueName());
            }
        } 
        else if (!isRightChildOfDot()) 
        {   out.print("this.");
            TypeDecl t = hostType();
            if (t!=m.hostType() && t.isInnerTypeOf(m.hostType())) 
            {   while (t!=m.hostType()) 
                {   out.print("_o.");
                    t = t.enclosingType();
                }
            }
            out.printJSIdentifier(m.name(),"_"+m.getNumParameter());
            out.print("(");
        }
        else if (prevExpr().isSuperAccess()) 
        {   out.printAndMemorizeReference(m.hostType().packageName(),m.hostType().uniqueName());
            out.print(".prototype.");  		
            out.printJSIdentifier(m.name(),"_"+m.getNumParameter());
            out.print(".call(this");
            if (m.getNumParameter()>0) out.print(",");
        }
        else
        {   out.print(".");
            out.printJSIdentifier(m.name(),"_"+m.getNumParameter());
            out.print("(");
        }

        // generate parameters 
        for (int i=0; i<getNumArg(); i++) {
            if (i>0) out.print(",");
            // do necessary data conversion for some built-in methods 
            // to clarify the use of a char instead of a int 
            TypeDecl ht = m.hostType();
            String tn = ht.packageName() + "." + ht.uniqueName();
            if 
            (   i==0 && getNumArg()==1 && getArg(0).type().isChar() && 
                (   (m.name().equals("append") && tn.equals("java.lang.StringBuffer"))
                    || (m.name().equals("append") && tn.equals("java.lang.StringBuilder"))
                    || (m.name().equals("print") && tn.equals("java.io.PrintStream"))
                    || (m.name().equals("println") && tn.equals("java.io.PrintStream"))
                ) 
            ) 
            {   out.print("_c2s(");  	
                getArg(i).generateUsingResultJS(out);
                out.print(")");  	
            } 
            else 
            {  getArg(i).generateUsingResultJS(out);
            }
        }
        out.print(")");
    }

//  	public void PackageAccess.generateJS(CodePrinter out) {
// 	}
//  	public void ParseName.generateJS(CodePrinter out) {
// 	}
  	public void SuperAccess.generateJS(CodePrinter out) {
  		// do not generate anything - must be implemented by the method or variable access
//  		out.printAndMemorizeReference(type().packageName(),type().uniqueName());
//  		out.print(".prototype");
 	}
  	public void ThisAccess.generateJS(CodePrinter out) {
  		out.print("this");
 	}
  	public void TypeAccess.generateJS(CodePrinter out) {
 	}
  	public void ArrayTypeAccess.generateJS(CodePrinter out) {
  		getAccess().generateJS(out);
	}
  	public void ArrayTypeWithSizeAccess.generateJS(CodePrinter out) {
  		getAccess().generateJS(out);
  		getExpr().generateJS(out);
  		out.print(",");
	}   	

  	public void VarAccess.generateJS(CodePrinter out) {
  		Variable v = varDecl();
  		if (v.isClassVariable()) {
  			TypeDecl t = v.hostType();
  			out.printAndMemorizeReference(t.packageName(),t.uniqueName());  		
  			out.print(".");
  			out.printJSIdentifier(getID(),"");  
  			// check if this is inside a static initializer - must force early loading of accessed class
	  		BodyDecl bd = enclosingBodyDecl();
  			if (bd.isField() || (bd instanceof StaticInitializer)) {
  				out.memorizeComplete(t.packageName(),t.uniqueName());
  			}  		  						  			
  		} else if (v.isInstanceVariable()) {
			if (isRightChildOfDot()) {
				out.print(".");
			} else {
				out.print("this.");
				TypeDecl t = hostType();
				if (t!=v.hostType() && t.isInnerTypeOf(v.hostType())) {
					while (t!=v.hostType()) {
						out.print("_o.");
						t = t.enclosingType();
					}
				}  		
  			}  		
			out.printJSIdentifier(getID(),"");
        } else if (v.isLocalVariable() || v.isParameter()) 
        {   if (v.hostType() == hostType()) 
            {   out.printJSIdentifier(getID(), "");
            }
            else 
            {   // this must be an access to local variable of calling method
                out.print("this.");
                out.printJSIdentifier(getID(), "_o");
            }
		} else if (getID().equals("length")) {
			out.print(".length");
  		} else {
			throw new RuntimeException("Unknown type of variable access");
  		}  		
 	}
  	
  	// --- ArrayInit ---
  	
  	public void ArrayInit.generateJS(CodePrinter out) {
  		out.print("[");
  		for (int i=0; i<getNumInit(); i++) {
  			if (i>0) out.print(",");
  			getInit(i).generateUsingResultJS(out);
  		}
  		out.print("]");
  	}
  	
  	// --- AssignExpr ---

	public void AssignExpr.generateWithOptionalCastJS(CodePrinter out, String operator) {
  		Expr d = getDest();
  		Expr s = getSource();
  		if (d.type().isDouble()) {
	  		d.generateJS(out);
	  		out.print(" ");
	  		out.print(operator);
  			out.print("= ");
  			s.generateUsingResultJS(out);
  		} else if (s.type().isDouble()) {
	  		d.generateJS(out);
  			out.print(" = ");
  			if (d.type().isByte()) {
  				out.print("_castTObyte(");
  			} else if (d.type().isChar()) {
  				out.print("_castTOchar(");
  			} else if (d.type().isInt()) {
  				out.print("_castTOint(");
  			} else {
  				throw new RuntimeException("Can not implicitly cast to destination type");
  			}
	  		d.generateJS(out);
	  		out.print(" ");
	  		out.print(operator);
	  		out.print(" ");
  			s.generateUsingResultJS(out);
			out.print(")");
  		} else {
  			d.generateJS(out);
  			out.print(" = ((");
  			d.generateJS(out);
  			out.print(" ");
  			out.print(operator);
  			out.print(" ");
  			getSource().generateUsingResultJS(out);
  			out.print(")&-1)");  		
  		}
	}

  	public void AssignMinusExpr.generateJS(CodePrinter out) {
  		generateWithOptionalCastJS(out,"-");
  	}
  	public void AssignPlusExpr.generateJS(CodePrinter out) {
  		// do some case discrimination if this is a string concatenation
  		Expr d = getDest();
  		Expr s = getSource();
  		if (type().isString()) {
  			d.generateJS(out);
  			out.print(" += \"\"+");
  			if (s.type().isChar()) {
  				out.print("_c2s(");
  				s.generateJS(out);
  				out.print(")");
  			} else {
  				s.generateJS(out);
  			}
  		} else {
	  		generateWithOptionalCastJS(out,"+");
  		}
  	}
  	public void AssignMulExpr.generateJS(CodePrinter out) {
  		generateWithOptionalCastJS(out,"*");
  	}  	
  	public void AssignDivExpr.generateJS(CodePrinter out) {
  		generateWithOptionalCastJS(out,"/");
  	}
  	
  	public void AssignAndExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" &= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignOrExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" |= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignXorExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" ^= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignModExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" %= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignLShiftExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" <<= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignRShiftExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" >>= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignURShiftExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" >>>= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignSimpleExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" = ");
  		getSource().generateUsingResultJS(out);
  	}
  	  	
  	// --- Binary ---

  	public void AddExpr.generateJS(CodePrinter out) {
  		// do some case discrimination if this is a string concatenation
  		Expr l = getLeftOperand();
  		Expr r = getRightOperand();
  		if (type().isString()) {
			if ((l.type().isString() && l.isConstant()) || (l instanceof AddExpr)) {
				l.generateUsingResultJS(out);
  			} else if (l.type().isChar()) {
  				out.print("_c2s(");
  				l.generateUsingResultJS(out);
  				out.print(")");
			} else if (l.type().isReferenceType()) {
  				out.print("_str(");
  				l.generateUsingResultJS(out);
  				out.print(")");  		
  			} else {
  				l.generateUsingResultJS(out);
  			}
  			out.print("+\"\"+");
			if ((r.type().isString() && r.isConstant()) || (r instanceof AddExpr)) {
				r.generateUsingResultJS(out);
  			} else if (r.type().isChar()) {
  				out.print("_c2s(");
  				r.generateUsingResultJS(out);
  				out.print(")");
  			} else if (r.type().isReferenceType()) {
  				out.print("_str(");
  				r.generateUsingResultJS(out);
  				out.print(")");  		
  			} else {
  				r.generateUsingResultJS(out);  			 
  			}
  		} else if (type().isDouble()) {
	  		l.generateUsingResultJS(out);
  			out.print(" + ");
  			r.generateUsingResultJS(out);
  		} else {
  			out.print("((");
	  		l.generateUsingResultJS(out);
  			out.print(" + ");
  			r.generateUsingResultJS(out);
  			out.print(")&-1)");
  		}
  	}
  	public void SubExpr.generateJS(CodePrinter out) {
  		Expr l = getLeftOperand();
  		Expr r = getRightOperand();  	
  		if (type().isDouble()) {
	  		l.generateUsingResultJS(out);
  			out.print(" - ");
  			r.generateUsingResultJS(out);
  		} else {
  			out.print("((");
	  		l.generateUsingResultJS(out);
  			out.print(" - ");
  			r.generateUsingResultJS(out);
  			out.print(")&-1)");
  		}
  	}
  	public void DivExpr.generateJS(CodePrinter out) {
	  		Expr l = getLeftOperand();
  			Expr r = getRightOperand();  	
		if (type().isDouble()) {
	  		l.generateUsingResultJS(out);
  			out.print(" / ");
  			r.generateUsingResultJS(out);
  		} else {  	
  			out.print("((");
	  		l.generateUsingResultJS(out);
  			out.print(" / ");
  			r.generateUsingResultJS(out);
  			out.print(")&-1)");
  		}
  	}
  	public void MulExpr.generateJS(CodePrinter out) {
  		Expr l = getLeftOperand();
  		Expr r = getRightOperand();  	
  		if (type().isDouble()) {
	  		l.generateUsingResultJS(out);
  			out.print(" * ");
  			r.generateUsingResultJS(out);
  		} else {
  			out.print("((");
	  		l.generateUsingResultJS(out);
  			out.print(" * ");
  			r.generateUsingResultJS(out);
  			out.print(")&-1)");
  		}
  	}
  	public void ModExpr.generateJS(CodePrinter out) {
 		getLeftOperand().generateUsingResultJS(out);
		out.print(" % ");
		getRightOperand().generateUsingResultJS(out);
  	}  	
  	public void AndBitwiseExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" & ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void OrBitwiseExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" | ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void XorBitwiseExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" ^ ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void AndLogicalExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" && ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void OrLogicalExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" || ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void EQExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" === ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void NEExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" != ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void GEExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" >= ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void GTExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" > ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void LEExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" <= ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void LTExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" < ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void LShiftExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" << ");
  		getRightOperand().generateUsingResultJS(out);

  	}
  	public void RShiftExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" >> ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void URShiftExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" >>> ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	
  	
  	// --- CastExpr ---
  	
  	public void CastExpr.generateJS(CodePrinter out) {
		TypeDecl t = type();
		if (t.isPrimitiveType()) {
			if (t.isByte()) { 
				out.print("_castTObyte(");
				getExpr().generateUsingResultJS(out);
				out.print(")");
			} else if (t.isChar()) {
				out.print("_castTOchar(");
				getExpr().generateUsingResultJS(out);
				out.print(")");
			} else if (t.isInt()) {
				out.print("_castTOint(");
				getExpr().generateUsingResultJS(out);
				out.print(")");
			} else if (t.isDouble()) {
				getExpr().generateUsingResultJS(out);
			} else {
				throw new RuntimeException("Type not supported:"+t.fullName());
			}
		} else {
  			getExpr().generateUsingResultJS(out);
  		}
  	}
  	
  	// --- ConditionalExpr ---
  	
  	public void ConditionalExpr.generateJS(CodePrinter out) {
  		getCondition().generateUsingResultJS(out);
  		out.print("?");
  		getTrueExpr().generateUsingResultJS(out);
  		out.print(":");
  		getFalseExpr().generateUsingResultJS(out);
  	}
  	
  	// --- InstanceOfExpr ---

  	public void InstanceOfExpr.generateJS(CodePrinter out) {
  	  	TypeDecl t = getTypeAccess().type();
  	  	if (t.isArrayDecl()) {
  	  		out.print("false");
  	  		throw new RuntimeException("Can not create type check for array types");
  	  	} else if (!t.isReferenceType()) {
  	  		out.print("false");
  	  		throw new RuntimeException("Can not create type check for primitive types");
  	  	} else {
	  		out.print("(_denullify(");
  			getExpr().generateUsingResultJS(out);
  			out.print(").");
	  		out.print("_is_");
	  		out.printAndMemorizeReference(t.packageName(),t.uniqueName());
  			out.print(")");
  		}
  	}
  	
  	// --- PrimaryExpr ---
  	
  	public void ArrayCreationExpr.generateJS(CodePrinter out) {
  		if (hasArrayInit()) {
  			getArrayInit().generateJS(out);
  		} else {
  			Access ta = getTypeAccess();
	  		out.print("_dim([");  		
			ta.generateJS(out);
			out.print("],");
			if ((ta instanceof ArrayTypeWithSizeAccess) 
			 && ta.type().elementType().isPrimitiveType()) { 
				out.print(ta.type().elementType().isBoolean()?"false":"0");
			} else {
				out.print("null");
			}								
			out.print(")");  		
  		}
  	}
  	public void Literal.generateJS(CodePrinter out) {
  		constant().generateJS(out);
  	}
//  	public void IllegalLiteral.generateCS(CodePrinter out) {
//  	}
  	public void NullLiteral.generateJS(CodePrinter out) {
  		out.print("null");
  	}
  	
  	public void ParExpr.generateJS(CodePrinter out) {
  		out.print("(");
  		getExpr().generateJS(out);
  		out.print(")");
  	}
  	
  	// --- Unary ---
  	public void BitNotExpr.generateJS(CodePrinter out) {
  		out.print(" ~ ");
  		getOperand().generateUsingResultJS(out);  	
  	}
  	public void LogNotExpr.generateJS(CodePrinter out) {
  		out.print(" ! ");
  		getOperand().generateUsingResultJS(out);  	
  	}
  	public void MinusExpr.generateJS(CodePrinter out) {
  		out.print("(-(");
  		getOperand().generateUsingResultJS(out);  	
  		out.print(")&-1)");
  	}
  	public void PlusExpr.generateJS(CodePrinter out) {
  		getOperand().generateUsingResultJS(out);  	
  	}
  	
  	
  	public void Unary.generatePostOperatorJS(CodePrinter out, boolean inc)
  	{
  		Expr e = getOperand();
  		if (e.type().isDouble()) {
  			e.generateJS(out);
  			out.print(inc?" ++ ":" -- ");
  			return;
  		}
  		
  		boolean needresult = !(getParent() instanceof ExprStmt);
  		if (needresult) {
  			out.print("(((");
  		}
  		
		e.generateUsingResultJS(out);
		out.print("=(");
		e.generateUsingResultJS(out);
		out.print(inc?" +1)":" -1)");
		if (e.type().isInt()) {
			out.print("&-1");
		} else if (e.type().isChar()) {
			out.print("&0xffff");
		} else if (e.type().isByte()) {
			out.print("<<24>>24");
		}
  	
  		if (needresult) {
  			out.print(")");
  			// must revert the operation to get the original value out
			out.print(inc?" -1)":" +1)");
			if (e.type().isInt()) {
				out.print("&-1");
			} else if (e.type().isChar()) {
				out.print("&0xffff");
			} else if (e.type().isByte()) {
				out.print("<<24>>24");
			}
			out.print(")");
  		}  	  	
  	}
  	public void Unary.generatePreOperatorJS(CodePrinter out, boolean inc)
  	{
  		Expr e = getOperand();
  		if (e.type().isDouble()) {
  			out.print(inc?" ++ ":" -- ");
  			e.generateJS(out);
  			return;
  		}
  		
  		boolean needresult = !(getParent() instanceof ExprStmt);
  		if (needresult) {
  			out.print("(");
  		}
		
		e.generateUsingResultJS(out);
		out.print("=(");
		e.generateUsingResultJS(out);
		out.print(inc?" +1)":" -1)");
		if (e.type().isInt()) {
			out.print("&-1");
		} else if (e.type().isChar()) {
			out.print("&0xffff");
		} else if (e.type().isByte()) {
			out.print("<<24>>24");
		}
		
  		if (needresult) {
  			out.print(")");
  		}  	
  	}  	
  	public void PostDecExpr.generateJS(CodePrinter out) {
  		generatePostOperatorJS(out, false);
  	}
  	public void PostIncExpr.generateJS(CodePrinter out) {
  		generatePostOperatorJS(out, true);
  	}
  	public void PreDecExpr.generateJS(CodePrinter out) {
  		generatePreOperatorJS(out,false);
  	}
  	public void PreIncExpr.generateJS(CodePrinter out) {
  		generatePreOperatorJS(out,true);
  	}  	

  	  	
  	
}

