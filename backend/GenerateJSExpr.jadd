import com.greentube.javaconverter.CodePrinter;
aspect GenerateJS {
 
 	public void Expr.generateUsingResultJS(CodePrinter out) {	
		if (isConstant() && !type().isEnumDecl()) {
			constant().generateJS(out);  		
 		} else {
 			generateJS(out);
 		}
	}
	 
 	// --- Access --- 
 	
  	public void AbstractDot.generateJS(CodePrinter out) {
  		Access a = getRight();
  		if (! (a instanceof ClassInstanceExpr)) {
  			getLeft().generateJS(out);
  		}
  		a.generateJS(out);
 	}
//  	public void Wildcard.generateJS(CodePrinter out) {
// 	}
//  	public void WildcardExtends.generateJS(CodePrinter out) {
// 	}
//  	public void WildcardSuper.generateJS(CodePrinter out) {
// 	}
  	public void ArrayAccess.generateJS(CodePrinter out) {
  		out.print("[");
  		getExpr().generateUsingResultJS(out);
  		out.print("]");
 	}
//  	public void ClassAccess.generateJS(CodePrinter out) {
// 	}
  	public void ClassInstanceExpr.generateJS(CodePrinter out) {
  		out.print("(new ");
  		out.printAndMemorizeReference(type().packageName(), type().uniqueName());
		out.print("(");  		
		if (isRightChildOfDot()) {
			prevExpr().generateJS(out);
  		} else if (type().isInnerClass()) {
  			out.print("this");
  		}  		

  		ConstructorDecl m = decl();
  		out.print("))._"+m.getNumParameter()+"(");
  		
  		// check if must create a temporary array to package the var args   	
		if (!m.isVariableArity() 
		|| (getNumArg()==m.getNumParameter() && getArg(getNumArg()-1).type()==m.getParameter(getNumArg()-1).type()) ) 
		// can leave parameters as they are
		{
	  		for (int i=0; i<getNumArg(); i++) {
  				if (i>0) out.print(",");
  				getArg(i).generateUsingResultJS(out);
  			}
  		// need to package last parameters (may be zero) into array		
  		} else {
  			// non-varargs parameters
	  		for (int i=0; i<m.getNumParameter()-1; i++) {
  				if (i>0) out.print(",");
  				getArg(i).generateUsingResultJS(out);
  			}  		
  			// create array for the rest
  			if (m.getNumParameter()>1) out.print(",");
  			out.print("[");
  			for (int i=m.getNumParameter()-1; i<getNumArg(); i++) {
  				if (i>m.getNumParameter()-1) out.print(",");
  				getArg(i).generateUsingResultJS(out);
  			}
  			out.print("]");  			
  		}
  		
  		out.print(")");
  		
  		// check if this is inside a static initializer - must force early loading of created class
  		if (enclosingBodyDecl().isField()) {
  			out.memorizeComplete(type().packageName(),type().uniqueName());
  		}
 	}
  	public void ConstructorAccess.generateJS(CodePrinter out) {
  		TypeDecl ht = decl().hostType();
			out.printAndMemorizeReference(ht.packageName(), ht.uniqueName());

	  		ConstructorDecl m = decl();
			out.print(".prototype._" + m.getNumParameter() + ".call(this");
	  		
	  		// check if must create a temporary array to package the var args   	
			if (!m.isVariableArity() 
			|| (getNumArg()==m.getNumParameter() && getArg(getNumArg()-1).type()==m.getParameter(getNumArg()-1).type()) ) 
			// can leave parameters as they are
			{
		  		for (int i=0; i<getNumArg(); i++) {
	  				out.print(",");
	  				getArg(i).generateUsingResultJS(out);
	  			}
	  		// need to package last parameters (may be zero) into array		
	  		} else {
	  			// non-varargs parameters
		  		for (int i=0; i<m.getNumParameter()-1; i++) {
	  				out.print(",");
	  				getArg(i).generateUsingResultJS(out);
	  			}  		
	  			// create array for the rest
	  			if (m.getNumParameter()>1) out.print(",");
	  			out.print("[");
	  			for (int i=m.getNumParameter()-1; i<getNumArg(); i++) {
	  				if (i>m.getNumParameter()-1) out.print(",");
	  				getArg(i).generateUsingResultJS(out);
	  			}
	  			out.print("]");  			
	  		}
	
			out.print(")");
 	}
 	
//  	public void DiamondAccess.generateJS(CodePrinter out) {
// 	}
  	public void MethodAccess.generateJS(CodePrinter out) {
  		MethodDecl m = decl();
  		
  		if (m.isStatic()) {
			TypeDecl t = m.hostType();
  			out.printAndMemorizeReference(t.packageName(),t.uniqueName());
  			out.print(".");
  			out.printJSIdentifier(m.name(),"_"+m.getNumParameter());
  			out.print("(");

	  		// check if this is inside a static initializer - must force early loading of accessed class
	  		BodyDecl bd = enclosingBodyDecl();
  			if (bd.isField() || (bd instanceof StaticInitializer)) {
  				out.memorizeComplete(t.packageName(),t.uniqueName());
  			}
  			
  		} else if (!isRightChildOfDot()) {
			out.print("this.");
			TypeDecl t = hostType();
			if (t!=m.hostType() && t.isInnerTypeOf(m.hostType())) {
				while (t!=m.hostType()) {			
					out.print("_o.");
					t = t.enclosingType();
				}
			}  		
  			out.printJSIdentifier(m.name(),"_"+m.getNumParameter());
  			out.print("(");
  			
  		} else if (prevExpr().isSuperAccess()) {  		
  			out.printAndMemorizeReference(m.hostType().packageName(),m.hostType().uniqueName());
  			out.print(".prototype.");  		
			out.printJSIdentifier(m.name(),"_"+m.getNumParameter());
			out.print(".call(this");
  			if (m.getNumParameter()>0) out.print(",");
  			
  		} else {
  			out.print(".");
  			out.printJSIdentifier(m.name(),"_"+m.getNumParameter());
  			out.print("(");
  		}

		// check if this is a method with variable number of parameters - must 
		// package last arguments into array
		int pararraystart=-1;
		if (m.isVariableArity()) {		
			if (getNumArg()==m.getNumParameter() 
			 && getArg(getNumArg()-1).type()==m.getParameter(getNumArg()-1).type() ) {
			 	// the call uses an explicit array already - no implicit array creation needed
			} else {
				pararraystart = m.getNumParameter()-1;
			}
  		}
  		// generate parameters and inject one '[' in the correct position
  		for (int i=0; i<getNumArg(); i++) {
  			if (i>0) out.print(",");
  			if (pararraystart==i) out.print("[");
  			getArg(i).generateUsingResultJS(out);
  		}
  		if (pararraystart>=0) {
  			if (pararraystart>=getNumArg()) out.print(pararraystart>0 ? ",[" : "[");
  			out.print("]");
  		}
  		out.print(")");  	
 	}
//  	public void PackageAccess.generateJS(CodePrinter out) {
// 	}
//  	public void ParseName.generateJS(CodePrinter out) {
// 	}
  	public void SuperAccess.generateJS(CodePrinter out) {
  		// do not generate anything - must be implemented by the method or variable access
//  		out.printAndMemorizeReference(type().packageName(),type().uniqueName());
//  		out.print(".prototype");
 	}
  	public void ThisAccess.generateJS(CodePrinter out) {
  		out.print("this");
 	}
  	public void TypeAccess.generateJS(CodePrinter out) {
 	}
  	public void ArrayTypeAccess.generateJS(CodePrinter out) {
  		getAccess().generateJS(out);
	}
  	public void ArrayTypeWithSizeAccess.generateJS(CodePrinter out) {
  		getAccess().generateJS(out);
  		getExpr().generateJS(out);
  		out.print(",");
	}   	

  	public void VarAccess.generateJS(CodePrinter out) {
  		Variable v = varDecl();
  		if (v.isClassVariable()) {
  			TypeDecl t = v.hostType();
  			out.printAndMemorizeReference(t.packageName(),t.uniqueName());  		
  			out.print(".");
  			out.printJSIdentifier(getID(),"");  
  			// check if this is inside a static initializer - must force early loading of accessed class
	  		BodyDecl bd = enclosingBodyDecl();
  			if (bd.isField() || (bd instanceof StaticInitializer)) {
  				out.memorizeComplete(t.packageName(),t.uniqueName());
  			}  		  						  			
  		} else if (v.isInstanceVariable()) {
			if (isRightChildOfDot()) {
				out.print(".");
			} else {
				out.print("this.");
				TypeDecl t = hostType();
				if (t!=v.hostType() && t.isInnerTypeOf(v.hostType())) {
					while (t!=v.hostType()) {			
						out.print("_o.");
						t = t.enclosingType();
					}
				}  		
  			}  		
			out.printJSIdentifier(getID(),"");
  		} else if (v.isLocalVariable() || v.isParameter()) {  
  			if (v.hostType() == hostType()) {		
				out.printJSIdentifier(getID(), "");
			} else {  // this must be an access to local variable of calling method 
				throw new RuntimeException("Can not access local variables of outer class method");
			}
		} else if (getID().equals("length")) {
			out.print(".length");
  		} else {
			throw new RuntimeException("Unknown type of variable access");
  		}  		
 	}
  	
  	// --- ArrayInit ---
  	
  	public void ArrayInit.generateJS(CodePrinter out) {
  		out.print("[");
  		for (int i=0; i<getNumInit(); i++) {
  			if (i>0) out.print(",");
  			getInit(i).generateUsingResultJS(out);
  		}
  		out.print("]");
  	}
  	
  	// --- AssignExpr ---

	public void AssignExpr.generateWithOptionalCastJS(CodePrinter out, String operator) {
  		Expr d = getDest();
  		Expr s = getSource();
  		if (d.type().isDouble()) {
	  		d.generateJS(out);
	  		out.print(" ");
	  		out.print(operator);
  			out.print("= ");
  			s.generateUsingResultJS(out);
  		} else if (s.type().isDouble()) {
	  		d.generateJS(out);
  			out.print(" = ");
  			if (d.type().isByte()) {
  				out.print("_castTObyte(");
  			} else if (d.type().isChar()) {
  				out.print("_castTOchar(");
  			} else if (d.type().isInt()) {
  				out.print("_castTOint(");
  			} else {
  				throw new RuntimeException("Can not implicitly cast to destination type");
  			}
	  		d.generateJS(out);
	  		out.print(" ");
	  		out.print(operator);
	  		out.print(" ");
  			s.generateUsingResultJS(out);
			out.print(")");
  		} else {
  			d.generateJS(out);
  			out.print(" = ((");
  			d.generateJS(out);
  			out.print(" ");
  			out.print(operator);
  			out.print(" ");
  			getSource().generateUsingResultJS(out);
  			out.print(")&-1)");  		
  		}
	}

  	public void AssignMinusExpr.generateJS(CodePrinter out) {
  		generateWithOptionalCastJS(out,"-");
  	}
  	public void AssignPlusExpr.generateJS(CodePrinter out) {
  		// do some case discrimination if this is a string concatenation
  		Expr d = getDest();
  		Expr s = getSource();
  		if (type().isString()) {
  			d.generateJS(out);
  			out.print(" += \"\"+");
  			if (s.type().isChar()) {
  				out.print("_c2s(");
  				s.generateJS(out);
  				out.print(")");
  			} else {
  				s.generateJS(out);
  			}
  		} else {
	  		generateWithOptionalCastJS(out,"+");
  		}
  	}
  	public void AssignMulExpr.generateJS(CodePrinter out) {
  		generateWithOptionalCastJS(out,"*");
  	}  	
  	public void AssignDivExpr.generateJS(CodePrinter out) {
  		generateWithOptionalCastJS(out,"/");
  	}
  	
  	public void AssignAndExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" &= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignOrExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" |= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignXorExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" ^= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignModExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" %= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignLShiftExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" <<= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignRShiftExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" >>= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignURShiftExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" >>>= ");
  		getSource().generateUsingResultJS(out);
  	}
  	public void AssignSimpleExpr.generateJS(CodePrinter out) {
  		getDest().generateJS(out);
  		out.print(" = ");
  		getSource().generateUsingResultJS(out);
  	}
  	  	
  	// --- Binary ---

  	public void AddExpr.generateJS(CodePrinter out) {
  		// do some case discrimination if this is a string concatenation
  		Expr l = getLeftOperand();
  		Expr r = getRightOperand();
  		if (type().isString()) {
  			if (l.type().isChar()) {
  				out.print("_c2s(");
  				l.generateUsingResultJS(out);
  				out.print(")");
  			} else {
  				l.generateUsingResultJS(out);
  			}
  			out.print("+\"\"+");
  			if (r.type().isChar()) {
  				out.print("_c2s(");
  				r.generateUsingResultJS(out);
  				out.print(")");
  			} else {
  				r.generateUsingResultJS(out);
  			}
  		} else if (type().isDouble()) {
	  		l.generateUsingResultJS(out);
  			out.print(" + ");
  			r.generateUsingResultJS(out);
  		} else {
  			out.print("((");
	  		l.generateUsingResultJS(out);
  			out.print(" + ");
  			r.generateUsingResultJS(out);
  			out.print(")&-1)");
  		}
  	}
  	public void SubExpr.generateJS(CodePrinter out) {
  		Expr l = getLeftOperand();
  		Expr r = getRightOperand();  	
  		if (type().isDouble()) {
	  		l.generateUsingResultJS(out);
  			out.print(" - ");
  			r.generateUsingResultJS(out);
  		} else {
  			out.print("((");
	  		l.generateUsingResultJS(out);
  			out.print(" - ");
  			r.generateUsingResultJS(out);
  			out.print(")&-1)");
  		}
  	}
  	public void DivExpr.generateJS(CodePrinter out) {
	  		Expr l = getLeftOperand();
  			Expr r = getRightOperand();  	
		if (type().isDouble()) {
	  		l.generateUsingResultJS(out);
  			out.print(" / ");
  			r.generateUsingResultJS(out);
  		} else {  	
  			out.print("((");
	  		l.generateUsingResultJS(out);
  			out.print(" / ");
  			r.generateUsingResultJS(out);
  			out.print(")&-1)");
  		}
  	}
  	public void MulExpr.generateJS(CodePrinter out) {
  		Expr l = getLeftOperand();
  		Expr r = getRightOperand();  	
  		if (type().isDouble()) {
	  		l.generateUsingResultJS(out);
  			out.print(" * ");
  			r.generateUsingResultJS(out);
  		} else {
  			out.print("((");
	  		l.generateUsingResultJS(out);
  			out.print(" * ");
  			r.generateUsingResultJS(out);
  			out.print(")&-1)");
  		}
  	}
  	public void ModExpr.generateJS(CodePrinter out) {
 		getLeftOperand().generateUsingResultJS(out);
		out.print(" % ");
		getRightOperand().generateUsingResultJS(out);
  	}  	
  	public void AndBitwiseExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" & ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void OrBitwiseExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" | ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void XorBitwiseExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" ^ ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void AndLogicalExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" && ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void OrLogicalExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" || ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void EQExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" === ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void NEExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" != ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void GEExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" >= ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void GTExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" > ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void LEExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" <= ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void LTExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" < ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void LShiftExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" << ");
  		getRightOperand().generateUsingResultJS(out);

  	}
  	public void RShiftExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" >> ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	public void URShiftExpr.generateJS(CodePrinter out) {
  		getLeftOperand().generateUsingResultJS(out);
  		out.print(" >>> ");
  		getRightOperand().generateUsingResultJS(out);  	
  	}
  	
  	
  	// --- CastExpr ---
  	
  	public void CastExpr.generateJS(CodePrinter out) {
		TypeDecl t = type();
		if (t.isPrimitiveType()) {
			if (t.isByte()) { 
				out.print("_castTObyte(");
				getExpr().generateUsingResultJS(out);
				out.print(")");
			} else if (t.isChar()) {
				out.print("_castTOchar(");
				getExpr().generateUsingResultJS(out);
				out.print(")");
			} else if (t.isInt()) {
				out.print("_castTOint(");
				getExpr().generateUsingResultJS(out);
				out.print(")");
			} else if (t.isDouble()) {
				getExpr().generateUsingResultJS(out);
			} else {
				throw new RuntimeException("Type not supported:"+t.fullName());
			}
		} else {
  			getExpr().generateUsingResultJS(out);
  		}
  	}
  	
  	// --- ConditionalExpr ---
  	
  	public void ConditionalExpr.generateJS(CodePrinter out) {
  		getCondition().generateUsingResultJS(out);
  		out.print("?");
  		getTrueExpr().generateUsingResultJS(out);
  		out.print(":");
  		getFalseExpr().generateUsingResultJS(out);
  	}
  	
  	// --- InstanceOfExpr ---

  	public void InstanceOfExpr.generateJS(CodePrinter out) {
  	  	TypeDecl t = getTypeAccess().type();
  	  	if (t.isArrayDecl()) {
  	  		out.print("false");
  	  		throw new RuntimeException("Can not create type check for array types");
  	  	} else if (!t.isReferenceType()) {
  	  		out.print("false");
  	  		throw new RuntimeException("Can not create type check for primitive types");
  	  	} else {
	  		out.print("(_denullify(");
  			getExpr().generateUsingResultJS(out);
  			out.print(").");
	  		out.print("_is_");
	  		out.printAndMemorizeReference(t.packageName(),t.uniqueName());
  			out.print(")");
  		}
  	}
  	
  	// --- PrimaryExpr ---
  	
  	public void ArrayCreationExpr.generateJS(CodePrinter out) {
  		if (hasArrayInit()) {
  			getArrayInit().generateJS(out);
  		} else {
  			Access ta = getTypeAccess();
	  		out.print("_createArray(");  		
			ta.generateJS(out);
			
			if ((ta instanceof ArrayTypeWithSizeAccess) 
			 && ta.type().elementType().isPrimitiveType()) { 
				out.print("0");
			} else {
				out.print("null");
			}								
			out.print(")");  		
  		}
  	}
  	public void Literal.generateJS(CodePrinter out) {
  		constant().generateJS(out);
  	}
//  	public void IllegalLiteral.generateCS(CodePrinter out) {
//  	}
  	public void NullLiteral.generateJS(CodePrinter out) {
  		out.print("null");
  	}
  	
  	public void ParExpr.generateJS(CodePrinter out) {
  		out.print("(");
  		getExpr().generateJS(out);
  		out.print(")");
  	}
  	
  	// --- Unary ---
  	public void BitNotExpr.generateJS(CodePrinter out) {
  		out.print(" ~ ");
  		getOperand().generateUsingResultJS(out);  	
  	}
  	public void LogNotExpr.generateJS(CodePrinter out) {
  		out.print(" ! ");
  		getOperand().generateUsingResultJS(out);  	
  	}
  	public void MinusExpr.generateJS(CodePrinter out) {
  		out.print(" - ");
  		getOperand().generateUsingResultJS(out);  	
  	}
  	public void PlusExpr.generateJS(CodePrinter out) {
  		out.print(" + ");    
  		getOperand().generateUsingResultJS(out);  	
  	}
  	public void PostDecExpr.generateJS(CodePrinter out) {
  		getOperand().generateUsingResultJS(out);  	
  		out.print(" -- ");    
  	}
  	public void PostIncExpr.generateJS(CodePrinter out) {
  		getOperand().generateUsingResultJS(out);  	
  		out.print(" ++ ");    
  	}
  	public void PreDecExpr.generateJS(CodePrinter out) {
  		out.print(" -- ");    
  		getOperand().generateUsingResultJS(out);  	
  	}
  	public void PreIncExpr.generateJS(CodePrinter out) {
  		out.print(" ++ ");    
  		getOperand().generateUsingResultJS(out);  	
  	}
  	
}

