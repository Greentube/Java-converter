import java.util.regex.Pattern;

aspect Util {
    
    public boolean Expr.hasLessThan20Bits() {
        TypeDecl t = type();
        if (t.isChar() || t.isByte() || t.isBoolean()) return true;
        if (t.isInt() && isConstant()) {
            int i = constant().intValue();
            return  i >= 0xfff80000 && i <= 0x7ffff;
        }
        return false;
    }

    public TypeDecl Expr.neededDownCast() {
        return null;
    }

    public TypeDecl VarAccess.neededDownCast() {
        if (isFieldAccess() && (varDecl() instanceof FieldDeclarator)) {
            FieldDeclarator fd = (FieldDeclarator) varDecl();
            if (fd.isInstanceVariable() && fd.type() != fd.erasedField().type()) {
                return fd.type();
            }       
        }
        return null;        
    }
    
    public TypeDecl MethodAccess.neededDownCast() {
        MethodDecl m = decl();
        if (m.erasedMethod().type()!=m.type()) {
            return m.type();
        }
        return null;
    }
    
    
    
   public String DoubleLiteral.normalizedDigits() 
   {
        String lit = getLITERAL();
        if (lit.equals("Infinity")||lit.equals("-Infinity")||lit.equals("NaN")) return lit;        
        return super.normalizedDigits();
   }
   
    public boolean Block.executionCanReachBottom() 
    {
        if (getNumStmt()<1) return true;
        Stmt stmt = getStmt(getNumStmt()-1);
        if (stmt instanceof Block) 
        {   return ((Block) stmt).executionCanReachBottom();
        }
        if (stmt instanceof ReturnStmt 
        ||  stmt instanceof BreakStmt
        ||  stmt instanceof ContinueStmt) return false;
        return true;
    }
    
    public boolean Case.canBeReachedByFallThrough() 
    {   ASTNode b = getParent();
        int idx = b.getIndexOfChild(this);
        if (idx<1) return false;
        ASTNode prev = b.getChild(idx-1);

        if (prev instanceof Block && ! ((Block) prev).executionCanReachBottom()) return false; 
        if (prev instanceof ReturnStmt 
        ||  prev instanceof BreakStmt
        ||  prev instanceof ContinueStmt
        ||  prev instanceof Case) return false;

        return true;
    }

    public String Expr.regexToSearchString()
    {
        if (!isConstant()) 
        {   throw new RuntimeException("Regular expression must be compile-time constant");
        }
        String regex = constant().stringValue();
    
        // check if this is a well-formed Pattern at all
        try 
        {   Pattern.compile(regex);
        } catch (Exception e) 
        {   throw new RuntimeException("Malformed regular expression");
        }
    
        int l = regex.length();
        StringBuilder b = new StringBuilder();

        scanall: for (int i=0; i<l; i++)
        {   char c = regex.charAt(i);
            switch (c)
            {   // start of backslash escape
                case '\\':
                    i++;
                    c = regex.charAt(i);
                    switch (c)
                    {   case '\\':
                            b.append(c);
                            break;
                        case 'Q':       // start of quote
                        {   int cidx = regex.indexOf("\\E",i+1);
                            if (cidx<0) // unterminated quote extends to the end
                            {   b.append(regex.substring(i+1));
                                break scanall;
                            }   
                            b.append(regex.substring(i+1,cidx));
                            i = cidx+1;
                            break;
                        }                              
                        default:  // no other esacpe character is supported
                            throw new RuntimeException("Unsupported escape int regular expression");                                 
                    }
                    break;
                // characters with special meaning that are not supported
                case '[': 
                case '(':
                case '{':
                case '|':
                case '.': 
                case '^':
                case '$':
                case '?':
                case '*':
                case '+':
                    throw new RuntimeException("Unsupported functionality in regular expression");
                default:
                    b.append(c);
            }
        }
        
        return b.toString();
    }
   
    public ArrayList<BodyDecl> InterfaceDecl.recursivelyGetBodyDecl()
    {   ArrayList<BodyDecl> allm = new ArrayList<BodyDecl>();
        for (BodyDecl bd:getBodyDeclList())
        {   allm.add(bd);
        }
        for (TypeDecl si:superInterfaces())
        {   for (BodyDecl sm:((InterfaceDecl)si).recursivelyGetBodyDecl()) 
            {   if (!allm.contains(sm)) 
                {   allm.add(sm);
                }
            }
        }    
        return allm;
    }
}
