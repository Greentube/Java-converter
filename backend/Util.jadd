import java.util.regex.Pattern;

aspect Util {
    
    public boolean Expr.hasLessThan20Bits() {
        TypeDecl t = type();
        if (t.isChar() || t.isByte() || t.isBoolean()) return true;
        if (t.isInt() && isConstant()) {
            int i = constant().intValue();
            return  i >= 0xfff80000 && i <= 0x7ffff;
        }
        return false;
    }

    public TypeDecl Expr.neededDownCast() {
        return null;
    }

    public TypeDecl VarAccess.neededDownCast() {
        if (isFieldAccess() && (varDecl() instanceof FieldDeclarator)) {
            FieldDeclarator fd = (FieldDeclarator) varDecl();
            if (fd.isInstanceVariable() && fd.type() != fd.erasedField().type()) {
                return fd.type();
            }       
        }
        return null;        
    }
    
    public TypeDecl MethodAccess.neededDownCast() {
        MethodDecl m = decl();
        if (m.erasedMethod().type()!=m.type()) {
            return m.type();
        }
        return null;
    }
    
    
    
   public String DoubleLiteral.normalizedDigits() 
   {
        String lit = getLITERAL();
        if (lit.equals("Infinity")||lit.equals("-Infinity")||lit.equals("NaN")) return lit;        
        return super.normalizedDigits();
   }
   
    public boolean Block.executionCanReachBottom() 
    {
        if (getNumStmt()<1) return true;
        Stmt stmt = getStmt(getNumStmt()-1);
        if (stmt instanceof Block) 
        {   return ((Block) stmt).executionCanReachBottom();
        }
        if (stmt instanceof ReturnStmt 
        ||  stmt instanceof BreakStmt
        ||  stmt instanceof ContinueStmt) return false;
        return true;
    }
    
    public boolean Case.canBeReachedByFallThrough() 
    {   ASTNode b = getParent();
        int idx = b.getIndexOfChild(this);
        if (idx<1) return false;
        ASTNode prev = b.getChild(idx-1);

        if (prev instanceof Block && ! ((Block) prev).executionCanReachBottom()) return false; 
        if (prev instanceof ReturnStmt 
        ||  prev instanceof BreakStmt
        ||  prev instanceof ContinueStmt
        ||  prev instanceof Case) return false;

        return true;
    }

    public String Expr.regexToSearchString()
    {
        if (!isConstant()) 
        {   throw new RuntimeException("Regular expression must be compile-time constant");
        }
        String regex = constant().stringValue();
    
        // check if this is a well-formed Pattern at all
        try 
        {   Pattern.compile(regex);
        } catch (Exception e) 
        {   throw new RuntimeException("Malformed regular expression");
        }
    
        int l = regex.length();
        StringBuilder b = new StringBuilder();

        scanall: for (int i=0; i<l; i++)
        {   char c = regex.charAt(i);
            switch (c)
            {   // start of backslash escape
                case '\\':
                    i++;
                    c = regex.charAt(i);
                    switch (c)
                    {   case '\\':
                            b.append(c);
                            break;
                        case 'Q':       // start of quote
                        {   int cidx = regex.indexOf("\\E",i+1);
                            if (cidx<0) // unterminated quote extends to the end
                            {   b.append(regex.substring(i+1));
                                break scanall;
                            }   
                            b.append(regex.substring(i+1,cidx));
                            i = cidx+1;
                            break;
                        }                              
                        default:  // no other esacpe character is supported
                            throw new RuntimeException("Unsupported escape int regular expression");                                 
                    }
                    break;
                // characters with special meaning that are not supported
                case '[': 
                case '(':
                case '{':
                case '|':
                case '.': 
                case '^':
                case '$':
                case '?':
                case '*':
                case '+':
                    throw new RuntimeException("Unsupported functionality in regular expression");
                default:
                    b.append(c);
            }
        }
        
        return b.toString();
    }
   
    public ArrayList<BodyDecl> InterfaceDecl.recursivelyGetBodyDecl()
    {   ArrayList<BodyDecl> allm = new ArrayList<BodyDecl>();
        for (BodyDecl bd:getBodyDeclList())
        {   allm.add(bd);
        }
        for (TypeDecl si:superInterfaces())
        {   for (BodyDecl sm:((InterfaceDecl)si).recursivelyGetBodyDecl()) 
            {   if (!allm.contains(sm)) 
                {   allm.add(sm);
                }
            }
        }    
        return allm;
    }
    
    public boolean ClassDecl.hasMethodWithSignature(String sig, Collection<MethodDecl> ignore)
    {
         for (BodyDecl bd:getBodyDeclList())
         {  if (bd instanceof MethodDecl) 
            {   if
                (   ((MethodDecl) bd).signature().equals(sig)
                    && (ignore==null || !ignore.contains(bd)) 
                )
                { return true; }
            }
         }
         if (hasSuperClass())
         {   return ((ClassDecl)superclass()).hasMethodWithSignature(sig,ignore);
         }
         return false;
    }
        
    public int EnumDecl.determineOrdinal(String name) 
    {
        int ordinal = 0;
        for (EnumConstant ec:enumConstants()) 
        {   if (ec.getID().equals(name)) { return ordinal; }
            ordinal++;
        }
        return 0;
    }     
    
    
    // side effect detection
    public boolean Expr.hasPotentialSideEffects() 
    {   
        System.err.print("Side effect test encountered:"+this.getClass().getName());    
        return false;
    }    
    public boolean Dot.hasPotentialSideEffects() 
    {   
        return getLeft().hasPotentialSideEffects() || getRight().hasPotentialSideEffects();         
    }
    public boolean ArrayAccess.hasPotentialSideEffects() 
    {
        return getExpr().hasPotentialSideEffects();
    }
    public boolean ClassInstanceExpr.hasPotentialSideEffects() 
    {
        return true;
    }
    public boolean MethodAccess.hasPotentialSideEffects() 
    {
        return true;
    }
    public boolean ParTypeAccess.hasPotentialSideEffects() 
    {
        return getTypeAccess().hasPotentialSideEffects();
    }
    public boolean ThisAccess.hasPotentialSideEffects() 
    {
        return false;
    }
    public boolean SuperAccess.hasPotentialSideEffects() 
    {
        return false;
    }
    public boolean TypeAccess.hasPotentialSideEffects() 
    {
        return false;
    }
    public boolean ArrayTypeAccess.hasPotentialSideEffects() 
    {
        return getAccess().hasPotentialSideEffects();
    }   
    public boolean ArrayTypeWithSizeAccess.hasPotentialSideEffects() 
    {
        return getAccess().hasPotentialSideEffects()
            || getExpr().hasPotentialSideEffects();
    }           
    public boolean VarAccess.hasPotentialSideEffects() 
    {
        return false;
    }
    public boolean ArrayInit.hasPotentialSideEffects() 
    {
        for (int i=0; i<getNumInit(); i++) 
        {   if (getInit(i).hasPotentialSideEffects()) { return true; }
        }
        return false;
    }
    public boolean AssignExpr.hasPotentialSideEffects() 
    {   
        return true;
    }
    public boolean Binary.hasPotentialSideEffects() 
    {   
        return getLeftOperand().hasPotentialSideEffects() 
            || getRightOperand().hasPotentialSideEffects();
    }
    public boolean CastExpr.hasPotentialSideEffects() 
    {
        return getExpr().hasPotentialSideEffects();
    }
    public boolean ConditionalExpr.hasPotentialSideEffects() 
    {
        return getCondition().hasPotentialSideEffects() 
            || getTrueExpr().hasPotentialSideEffects()
            || getFalseExpr().hasPotentialSideEffects();
    }
    public boolean InstanceOfExpr.hasPotentialSideEffects() 
    {
        return getExpr().hasPotentialSideEffects();
    }    
    public boolean ArrayCreationExpr.hasPotentialSideEffects() 
    {
        // array with initialization data
        if (hasArrayInit()) 
        {   return getArrayInit().hasPotentialSideEffects();
        } else 
        {   return getTypeAccess().hasPotentialSideEffects();
        }
    }
    public boolean Literal.hasPotentialSideEffects() 
    {   
        return false;
    }
    public boolean ParExpr.hasPotentialSideEffects() 
    {   
        return getExpr().hasPotentialSideEffects();
    }
    public boolean Unary.hasPotentialSideEffects() 
    {   
        return getOperand().hasPotentialSideEffects();
    }
    public boolean PostDecExpr.hasPotentialSideEffects() 
    {   
        return true;
    }
    public boolean PostIncExpr.hasPotentialSideEffects() 
    {
        return true;
    }
    public boolean PreDecExpr.hasPotentialSideEffects() 
    {
        return true;
    }
    public boolean PreIncExpr.hasPotentialSideEffects() 
    {
        return true;
    }    
    
    // ensure that an expression can never be null
    public boolean Expr.isNeverNull()
    {   
        return false;
    }
    public boolean Dot.isNeverNull() 
    {   
        return getRight().isNeverNull();         
    }    
    public boolean ArrayCreationExpr.isNeverNull()
    {   
        return true;
    }
    public boolean ParExpr.isNeverNull() 
    {   
        return getExpr().isNeverNull();
    }
    public boolean ClassInstanceExpr.isNeverNull()
    {   
        return true;
    }
    public boolean LambdaExpr.isNeverNull() 
    {   
        return true;
    }
    public boolean TypeMethodReference.isNeverNull()
    {   
        return true;
    }
    public boolean ExprMethodReference.isNeverNull()
    {   
        return true; 
    }
    public boolean VarAccess.isNeverNull()
    {   
        Variable v = decl();
        if (v.isEffectivelyFinal()) 
        {   return v.getInit().isNeverNull();
        }
        return false;
    } 
    public boolean MethodAccess.isNeverNull()
    {
        // some well known core library functions will never return null
        MethodDecl m = decl().erasedMethod();
        if (m.hostType().packageName().equals("java.util") 
         && m.hostType().uniqueName().equals("Comparator"))
        {   return true;
        }
        return false;
    }    

    public boolean MethodDecl.isSupportedInLibraries()
    {
        // test for availability in supported core libraries
        StringBuffer b = new StringBuffer(type().erasure().typeName());
        b.append(" ");
        b.append(name());
        b.append("(");
        for (int i=0; i<getNumParameter(); i++) 
        {   if (i!=0) { b.append(", "); }
            String typename = getParameter(i).type().erasure().typeName();
            b.append(typename);
        }
        b.append(")");          
        String sig = b.toString();
        String tn = hostType().packageName() + "." + hostType().uniqueName();
        return LibraryList.isAllowed(tn, sig);
    }
    
           
}
